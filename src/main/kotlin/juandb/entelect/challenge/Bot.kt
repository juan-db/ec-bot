package juandb.entelect.challenge

import juandb.entelect.challenge.command.BuildCommand
import juandb.entelect.challenge.command.Command
import juandb.entelect.challenge.command.DeconstructCommand
import juandb.entelect.challenge.command.DoNothingCommand
import juandb.entelect.challenge.entity.*
import juandb.entelect.challenge.entity.Building.BuildingType
import juandb.entelect.challenge.util.logger

class Bot(private val gameState: GameState) {
	private val logger by logger()

	private val gameDetails: GameDetails = gameState.gameDetails
	private val buildingStats: Map<BuildingType, BuildingStats> = gameDetails.buildingsStats

	/* Dimensions */
	private val gameWidth: Int = gameDetails.mapWidth
	private val gameHeight: Int = gameDetails.mapHeight
	/** The width of my side of the board. */
	private val myWidth: Int = gameWidth / 2

	/* Players */
	private val myself: Player = gameState.players.first { it.playerType == Player.PLAYER }
	private val opponent: Player = gameState.players.first { it.playerType == Player.ENEMY }

	private val mostExpensiveBuilding = buildingStats.maxBy { it.value.price }!!.key

	private val rows = gameState.gameMap.mapIndexed { index, cells -> RowState(index, cells) }
	private val buildableRows = rows.filter { it.friendlyEmptyCells.isNotEmpty() }
	private val occupiedRows = rows.filter { it.friendlyOccupiedCells.isNotEmpty() }

	private val commands: List<Command> = generateAvailableCommands()

	/**
	 * Gets all commands, weighs them according to expected gain. Gets a random command from the top weights.
	 *
	 * @return command string generated by the selected command.
	 */
	fun run(): String {
		val weightMap: Map<Command, Int> = commands.associate { command -> Pair(command, command.getWeight()) }
		logger.info("Available commands [${weightMap.size}]")

		val maxWeight: Int = weightMap.maxBy { (_, value) -> value }!!.value
		val filteredCommands: Set<Command> = weightMap.filterValues { it >= maxWeight }.keys
		logger.info("Best command count [${filteredCommands.size}] with weight [$maxWeight]")

		val selectedCommand: Command? = filteredCommands.shuffled().firstOrNull()
		logger.info("Selected command [$selectedCommand]")
		return selectedCommand?.getCommand() ?: ""
	}

	/**
	 * Creates a list of all available commands. Will always contain at least one command (the do nothing command).
	 * A command is considered "available" if it can legally be played, i.e. cell is open to place building, building
	 * can be afforded, etc.
	 *
	 * @return a list of all available commands.
	 */
	private fun generateAvailableCommands(): List<Command> {
		val output = ArrayList<Command>()

		/* Do nothing command. */
		output.add(DoNothingCommand(gameState))

		/* Add all possible build commands where I can afford the building. */
		val affordableBuildings = gameDetails.buildingsStats.filter { (_, stats) -> stats.canAfford(myself) }
		output.addAll(affordableBuildings.flatMap { building ->
			buildableRows.flatMap { row ->
				row.friendlyEmptyCells.map { cell ->
					BuildCommand.newBuildCommand(gameState, cell.x, cell.y, building.key)
				}
			}
		})

		/* Add deconstruction command for all cells with buildings. */
		output.addAll(occupiedRows.flatMap { row ->
			row.friendlyOccupiedCells.map {
				DeconstructCommand(gameState, it.x, it.y)
			}
		})

		return output
	}
}
